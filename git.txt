У Git есть три основных состояния, в которых могут находиться ваши файлы: 
зафиксированное (committed) - файл уже сохранён в вашей локальной базе.
изменённое (modified) - файлы, которые поменялись, но ещё не были зафиксированы.
подготовленное (staged) - изменённые файлы, отмеченные для включения в следующий коммит.

три основные секции проекта git:
Git-директория (Git directory)
рабочая директория (working directory)
область подготовленных файлов (staging area).

Git-директория — это то место, где Git хранит метаданные и базу объектов вашего проекта. 
Это самая важная часть Git, и это та часть, которая копируется при клонировании репозитория 
с другого компьютера.

Рабочая директория является снимком версии проекта. Файлы распаковываются из сжатой
базы данных в Git-директории и располагаются на диске, для того чтобы их можно было изменять 
и использовать.

Область подготовленных файлов — это файл, обычно располагающийся в вашей Git-директории, 
в нём содержится информация о том, какие изменения попадут в следующий коммит

Базовый подход в работе с Git выглядит так:

1)Вы изменяете файлы в вашей рабочей директории.

2)Вы выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, 
добавляя тем самым снимки только этих изменений в область подготовленных файлов.

3)Когда вы делаете коммит, используются файлы из индекса как есть, 
и этот снимок сохраняется в вашу Git-директорию.

git config --list используется, чтобы показать все настройки, которые Git найдёт.
Некоторые ключи (названия) настроек могут отображаться несколько раз, потому что 
Git читает настройки из разных файлов (например, из /etc/gitconfig и ~/.gitconfig).(1.6)

Так как Git читает значение настроек из нескольких файлов, возможна ситуация когда 
Git использует не то значение что вы ожидали. В таком случае вы можете спросить Git 
об origin этого значения. Git выведет имя файла, из которого значение для настройки 
было взято последним(1.6):
git config --show-origin rerere.autoUpdate

помощь по командам(1.7):
git help <команда>
git <команда> --help
man git-<команда>

сокращенный вывод git status:
git status -s

в commit попадут только файлы помеченые как Changes to be committed

при вызове git status -s:
Новые неотслеживаемые файлы помечены ?? слева от них
файлы добавленные в отслеживаемые помечены A
отредактированные файлы помечены M
и так далее.

в файле .gitignore указываются шаблоны файлов, которые вы не хотите 
автоматически добавлять в репозитори и видеть в списках неотслеживаемых

К шаблонам в файле .gitignore применяются следующие правила:
• Пустые строки, а также строки, начинающиеся с #, игнорируются.
• Стандартные шаблоны являются глобальными и применяются рекурсивно для всего
дерева каталогов.
• Чтобы избежать рекурсии используйте символ слэш (/) в начале шаблона.
• Чтобы исключить каталог добавьте слэш (/) в конец шаблона.
• Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве
первого символа.

git diff работает как git status, но он показывает какие именно строки были изменены

Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите git diff без
аргументов

Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит,
вы можете выполнить git diff --staged(или сached)

git commit фиксирует проиндексированные изменения

git commit -v покажет все изменения, которые вы совершили

git commit -m "Story 182: Fix benchmarks for speed"
#после -m указывается комментарий к коммиту

Добавление параметра -a в команду git commit заставляет Git
автоматически индексировать каждый уже отслеживаемый на момент коммита файл.
т.е коммитятся и не индексированные файлы.

git rm - удаление файла из рабочего каталога, так что в следующий раз
вы не увидите его как “неотслеживаемый”. Если вы просто удалите файл 
из своего рабочего каталога, он будет показан в секции 
“Changes not staged for commit”

Если вы изменили файл и уже проиндексировали его, вы должны использовать 
принудительное удаление с помощью параметра -f. 

git rm --cached file - удалить файл из индекса, оставив его при этом в 
рабочем каталоге

В команду git rm можно передавать файлы, каталоги или шаблоны.

git mv file_from file_to - переименовать файл в Git

git log - история коммитов

Опции oneline и format являются особенно полезными с опцией --graph команды log. С этой
опцией вы сможете увидеть небольшой граф в формате ASCII, который показывает текущую
ветку и историю слияний:

Наиболее распространенные опции для команды git log(стр 51)

git commit --amend - отмена коммита

Если вы сделаете изменения и создадите ещё один коммит, то он будет содержать указатель
на предыдущий коммит. Ветка в Git — это простой перемещаемый указатель на один из 
таких коммитов.(стр 71)

создание новой ветки с именем testing:
git branch testing

Как Git определяет, в какой ветке вы находитесь? Он хранит специальный указатель HEAD

переключение на ветку testing:
git checkout testing

Для просмотра истории коммитов ветки testing необходимо явно указать её
имя: git log testing. Чтобы посмотреть историю по всем веткам — выполните
команду с дополнительным флагом: git log --all.